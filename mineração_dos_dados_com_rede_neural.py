# -*- coding: utf-8 -*-
"""Mineração dos dados com rede neural.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ptmmzR2SHxXV5VNho49WirgN1QHxbzDF
"""

from google.colab import files

uploaded = files.upload()

import pandas as pd 
import io 
  
df = pd.read_csv(io.BytesIO(uploaded['data.csv'])) 
print(df)

# Carregar os dados
import sklearn
# Visualização
import matplotlib as mpl   
import matplotlib.pyplot as plt
import pandas as pd
# Construção da rede 
import numpy as np

#Criação do Data Frame
df1 = pd.read_csv('data.csv')
df1.sample(10)

#Transformação dos dados para dados computacionaveis
from sklearn.preprocessing import LabelEncoder
diagnosis = LabelEncoder()
df1['diagnosis'] = diagnosis.fit_transform(df1['diagnosis'])

df1.head() # 0 = B; 1 = M

#Limpeza dos dados, retirando colunas desnecesárias
df1.drop(columns =['id','Unnamed: 32'], axis=1, inplace=True)
df1.head()

#Aplicação da técnica Hold-Out
from sklearn.model_selection import train_test_split

x_train, x_test, y_train, y_test = train_test_split(df1.loc[:,df1.columns != 'diagnosis'],
                                                    df1['diagnosis'],
                                                    test_size=0.3)

x_test.head()

"""NORMALIZAÇÃO DE DADOS

"""

from sklearn import preprocessing
from keras import Sequential
from keras import Model
from keras.layers import Dense
from tensorflow.keras.optimizers import SGD 
from tensorflow import keras

preprocessParams = preprocessing.StandardScaler().fit(x_train)
x_train_normalized = preprocessParams.transform(x_train)
x_test_normalized = preprocessParams.transform(x_test)

x_train_normalized[:1]

#Criação da Rede 
RN = Sequential() 
RN.add(Dense(10, input_shape = x_train_normalized.shape[1:], activation ='sigmoid'))
RN.add(Dense(NumerOfClasses, activation ='sigmoid'))
RN.summary()

# Treinamento da rede neural de modelo sequencial
from tensorflow.keras.utils import to_categorical
sgd = SGD(lr=0.1, decay=1e-6, momentum=0.9)
RN.compile(optimizer=sgd, loss='mean_squared_error', metrics=['accuracy'])
trainedRN = RN.fit(x_train_normalized, to_categorical(y_train), epochs=100, verbose=1)

score = RN.evaluate(x_test_normalized, to_categorical(y_test),verbose=0)
print(f'Teste pontuação:{score[0]:.4f}')
print(f'Teste acurácia:{score[1]:.4f}')

#Predição 
from sklearn.metrics import confusion_matrix
y_test_predicted = RN.predict(x_test_normalized)
y_test_predicted_index = np.argmax(y_test_predicted, axis=1)
y_test_index = y_test.values

#Confusion Matrix
confMatrix = pd.DataFrame(confusion_matrix(y_test_predicted_index, y_test_index),
                           index=['0 - Benigno','1 - Maligno'],columns=['0 - Benigno','1 - Maligno'])

confMatrix.index.name = 'Real'
confMatrix.columns.name= 'Previsto'
print(confMatrix)